#pragma region  // clang-format off
#include <bits/stdc++.h>

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
typedef string str;
typedef int64_t Int;
typedef array<Int, 2> Pair;
typedef array<int, 3> Triple;

#define vec vector
#define pqueue priority_queue;
#define ALL(c) c.begin(),c.end()
#define SIZE(x) (int)x.size()

template <typename T>
using oset = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;

#define F_OR(i, a, b, s) for (int i = (a); (s > 0 ? i < (b) : i > (b)); i += (s))
#define F_OR1(e) F_OR(i, 0, e, 1)
#define F_OR2(i, e) F_OR(i, 0, e, 1)
#define F_OR3(i, b, e) F_OR(i, b, e, 1)
#define F_OR4(i, b, e, s) F_OR(i, b, e, s)
#define GET5(a, b, c, d, e, ...) e
#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)
#define FOR(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)

#define E_ACH2(x, a) for (auto& x: a)
#define E_ACH3(x, y, a) for (auto& [x, y]: a)
#define E_ACH4(x, y, z, a) for (auto& [x, y, z]: a)
#define E_ACHC(...) GET5(__VA_ARGS__, E_ACH4, E_ACH3, E_ACH2)
#define EACH(...) E_ACHC(__VA_ARGS__)(__VA_ARGS__)

template<class T> bool umin(T& a, const T& b) { 
	return b < a ? a = b, 1 : 0; }
template<class T> bool umax(T& a, const T& b) { 
	return a < b ? a = b, 1 : 0; } 
int FIRSTTRUE(function<bool(int)> f, int lo, int hi) {
	hi ++; assert(lo <= hi); // assuming f is increasing
	while (lo < hi) { // find first index such that f is true 
		int mid = (lo+hi)/2; 
		f(mid) ? hi = mid : lo = mid+1; 
	} 
	return lo;
}
int LASTTRUE(function<bool(int)> f, int lo, int hi) {
	lo--; assert(lo <= hi); // assuming f is decreasing
	while (lo < hi) { // find first index such that f is true 
		int mid = (lo+hi + 1)/2; 
		f(mid) ? lo = mid : hi = mid-1 ; 
	} 
	return lo;
}
int BITS(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) 
int CDIV(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0

template<class A> void read(vec<A>& v);
template<class A, size_t SZ> void read(array<A,SZ>& a);
template<class T> void read(T& x) { cin >> x; }
void read(double& d) { str t; read(t); d = stod(t); }
void read(long double& d) { str t; read(t); d = stold(t); }
template<class H, class... T> void read(H& h, T&... t) { read(h); read(t...); }
template<class A> void read(vec<A>& x) { EACH(a,x) read(a); }
template<class A, size_t SZ> void read(array<A,SZ>& x) { EACH(a,x) read(a); }

// TO_STRING
str to_string(char c) { return str(1, c); }
str to_string(bool b) { return b ? "true" : "false"; }
str to_string(const char* s) { return (str)s; }
str to_string(str s) { return s; }
str to_string(vec<bool> v) { 
	str res = ""; FOR(SIZE(v)) res += char('0'+v[i]); return res; }

template<size_t SZ> str to_string(bitset<SZ> b) {
	str res = ""; FOR(SZ) res += char('0'+b[i]);
	return res; }

template<class T> str to_string(T v) { // containers with begin(), end()
    bool f = 1;
    str res = "";
    EACH(x, v) {if (!f) res += " "; f=0; res += to_string(x);}
    return res;
}

// OUTPUT
template<class A> void write(A x) { cout << to_string(x); }
template<class H, class... T> void write(const H& h, const T&... t) { 
	write(h); write(t...); }
void print() { write("\n"); } // write w/ spaces
template<class H, class... T> void print(const H& h, const T&... t) { 
	write(h); if (sizeof...(t)) write(" "); print(t...); }
 
// DEBUG
void DBG() { cerr << "]" << endl; }
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h); if (sizeof...(t)) cerr << ", ";
	DBG(t...); }
#ifdef _DEBUG 
#define dbg(...) cerr << "LINE(" << __LINE__ << ") -> [" << #__VA_ARGS__ << "]: [", DBG(__VA_ARGS__)
#else
#define dbg(...) 0
#endif

#pragma endregion  // clang-format on

/////////////////////////////////////////////////////////////////
double dp[5001][5001];
double alpha[5001][5001];
double betas[5001][5001];

void solve(int tc) {
    int N; read(N);
    vec<int> A(N); read(A);
    vec<Int> P(N + 1);
    FOR(i, N) P[i+1] = P[i] + A[i];
    FOR(i, N) FOR(j, N) {
        dp[i][j] = 0.0;
        alpha[i][j] = 0.0;
        betas[i][j] = 0.0;
    }
    FOR(sz, 2, N + 1) FOR(i, N - sz + 1) {
        int j = i + sz - 1;
        alpha[i][j] = alpha[i][j-1] + dp[i][j-1];
        betas[i][j] = betas[i+1][j] + dp[i+1][j];
        double cand = (double)alpha[i][j] + (double) betas[i][j];
        cand /= (double)(j - i);
        dp[i][j] = cand + P[j+1] - P[i];
    }
    std::cout << "Case #" << (tc) << ": " << setprecision(9) << (dp[0][N-1]) << "\n";

}

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int T;
    read(T);
    FOR(T) solve(i + 1);
    return 0;
}